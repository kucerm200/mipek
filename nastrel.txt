====================
# input
5       # dimension
25      # max moves
4       # triangle
5 1
8 10 9
6 x 14 12
3 2 7 11 13
====================



====================
# check input
checkInput()
    # kontrola vstupu

# check output configuration
checkOutputTriangle()
    # true/false na spravnost
    # pokud triangle[0][0] != 'x' tak hned false
    # pokud triangle[0][0] == 'x' tak resime dal

# find white circle (nezamenit X a Y)
getXPositionOfx()
    # vratit index X
getYPositionOfx()
    # vratit index Y

# move functions
swapleft()
swapright()
swapupleft()
swapupright()
swapdownleft()
swapdownright()
    # osetrit indexy
    # prohodit cislo a x
====================



====================
# strom
pro x0 mám 6 možnostní
pro x1 mám nových 6 možností (celkem 36)
pro x2 mám nových 6 možností (celkem 216)
...
pro x25 mám nových 6 možností (celkem opravdu hodně :-D)
x26 je již určitě neplatný tah pro úlohu výše

=> s každým dalším tahem tahem je 6 nových možností
====================


====================
# alg slovne -- !!! asi je to spatne !!!
pro x0 udelam prvni typ tahu
pro x1 udelam prvni typ tahu
...
x25 je byl posledni tah...
vratim se zpet na x24 a udelam druhy typ tahu
x25 je byl posledni tah...
vratim se zpet na x24 a udelam treti typ tahu
....
vratim se zpet na x23 a udelam druhy typ tahu
....

=> Tedy zanořím se až na konec prvními možnostmi a budu se vracet zpět
====================



====================
# reseni pomoci rekurze
reseni(x, moves, max_move)
    if (moves > max_move)
        return false
    else if (checkTriangle(x))
        return moves    # mame reseni s moves tahy
    
    int r[6]
    
    r[0] = reseni(swapleft(x), moves + 1, max_move)
    r[1] = reseni(swapright(x), moves + 1, max_move)
    r[2] = reseni(swapupleft(x), moves + 1, max_move)
    r[3] = reseni(swapupright(x), moves + 1, max_move)
    r[4] = reseni(swapdownleft(x), moves + 1, max_move)
    r[5] = reseni(swapdownright(x), moves + 1, max_move)
    
    int bestOf = max_move
    
    for (int i=0; i<5; i++)
        if ((r[i] != false) && (r[i] < bestOf) ) # reseni proslo, mame pocet tahu
            bestOf = r[i]
            
    return bestOf
        

# pro kazdou uroven zkusim udelat 6 ruznych tahu,, zapocitam krok a posunu se na dalsi uroven
====================